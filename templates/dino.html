{% extends "base.html" %}
{% block content %}
<h2>Dino Game</h2>
<p>Press <strong>Space</strong> to start / restart and to jump.</p>

<canvas id="dinoGame" width="800" height="220" style="border:1px solid #000; display:block; margin-bottom:10px;"></canvas>

<div style="display:flex;gap:20px;align-items:center;">
  <div id="scoreDisplay" style="font-weight:bold">Score: 0</div>
  <div id="highscoreDisplay">Your Highscore: {{ user_highscore }}</div>
  <div id="gameOverMsg" style="color:#c00; font-weight:bold;"></div>
</div>

<h3>üèÜ Leaderboard</h3>
<table class="table table-striped">
  <thead>
    <tr><th>Rank</th><th>Player</th><th>Highscore</th></tr>
  </thead>
  <tbody id="leaderboardBody">
    {% for entry in leaderboard %}
    <tr {% if entry.username == user.username %}class="table-success"{% endif %}>
      <td>{{ loop.index }}</td>
      <td>{{ entry.username }}</td>
      <td>{{ entry.high }}</td>
    </tr>
    {% endfor %}
  </tbody>
</table>

<script>
(() => {
  const canvas = document.getElementById("dinoGame");
  const ctx = canvas.getContext("2d");

  // Config
  const GROUND_Y = 180;                // top coordinate where dino rests
  const DINO_W = 24, DINO_H = 24;
  const BASE_SPEED = 5;
  const BASE_SPAWN_FRAMES = 90;

  // State
  let gameRunning = false;
  let score = 0;
  let frameCount = 0;
  let speed = BASE_SPEED;
  let obstacles = [];
  let rafId = null;

  // Dino
  let dino = {
    x: 50,
    y: GROUND_Y,
    w: DINO_W,
    h: DINO_H,
    vy: 0,
    gravity: 1.1,
    jumpPower: -14
  };

  const scoreEl = document.getElementById("scoreDisplay");
  const highscoreEl = document.getElementById("highscoreDisplay");
  const gameOverEl = document.getElementById("gameOverMsg");

  function resetState() {
    score = 0;
    frameCount = 0;
    speed = BASE_SPEED;
    obstacles = [];
    dino.y = GROUND_Y;
    dino.vy = 0;
    gameOverEl.textContent = "";
    scoreEl.textContent = "Score: 0";
  }

  function startGame() {
    // cancel any left-over frame
    if (rafId) cancelAnimationFrame(rafId);
    resetState();
    gameRunning = true;
    rafId = requestAnimationFrame(gameLoop);
  }

  function spawnObstacle() {
    // as score grows we spawn more often and obstacles become taller
    const h = Math.floor(Math.random() * 40) + 20;
    const y = GROUND_Y + dino.h - h; // align to ground
    obstacles.push({ x: canvas.width + 10, y, w: 22, h, passed: false });
  }

  function jump() {
    // allow jumping if on (or very near) the ground
    if (dino.y >= GROUND_Y) {
      dino.vy = dino.jumpPower;
    }
  }

  function gameLoop() {
    // clear
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw ground line
    ctx.fillStyle = "#444";
    ctx.fillRect(0, GROUND_Y + dino.h, canvas.width, 2);

    // Dino physics
    dino.vy += dino.gravity;
    dino.y += dino.vy;
    if (dino.y > GROUND_Y) { dino.y = GROUND_Y; dino.vy = 0; }

    // Draw dino
    ctx.fillStyle = "#2c7";
    ctx.fillRect(dino.x, Math.round(dino.y), dino.w, dino.h);

    // Spawning logic: spawn more often as score grows
    const spawnFrames = Math.max(30, BASE_SPAWN_FRAMES - Math.floor(score / 120));
    if (frameCount % spawnFrames === 0) spawnObstacle();

    // Move & draw obstacles
    ctx.fillStyle = "#8b5a2b";
    for (let i = obstacles.length - 1; i >= 0; i--) {
      const o = obstacles[i];
      o.x -= speed;
      ctx.fillRect(Math.round(o.x), Math.round(o.y), o.w, o.h);

      // mark passed for scoring (optional)
      if (!o.passed && o.x + o.w < dino.x) { o.passed = true; }

      // collision
      if (dino.x < o.x + o.w &&
          dino.x + dino.w > o.x &&
          dino.y < o.y + o.h &&
          dino.y + dino.h > o.y) {
        endGame();
        return; // stop immediately
      }

      if (o.x + o.w < -50) obstacles.splice(i, 1);
    }

    // Score & difficulty progression
    score += 1;
    scoreEl.textContent = "Score: " + score;

    // bump speed gradually every X points
    if (score % 200 === 0) speed += 1;

    frameCount++;
    rafId = requestAnimationFrame(gameLoop);
  }

  function endGame() {
    // stop loop
    if (rafId) cancelAnimationFrame(rafId);
    gameRunning = false;
    gameOverEl.textContent = `Game Over ‚Äî Score: ${score}. Press Space to restart.`;

    // send score to backend (non-blocking)
    try {
      fetch("/dino/submit", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ score: score })
      })
      .then(r => r.json())
      .then(json => {
        if (json && json.highscore !== undefined) {
          highscoreEl.textContent = "Your Highscore: " + json.highscore;
        } else if (json && json.score) {
          // fallback
          highscoreEl.textContent = "Your Highscore: " + json.score;
        }
        // optionally refresh leaderboard by reloading the page or fetching leaderboard JSON
      })
      .catch(err => console.warn("Score save failed:", err));
    } catch (e) {
      console.warn("Fetch failed:", e);
    }
  }

  // universal key handler (Space/Up/W)
  document.addEventListener("keydown", (e) => {
    const code = e.code || e.key || e.keyCode;
    const isSpace = code === "Space" || code === " " || code === 32 || code === "Spacebar";
    if (!isSpace) return;
    e.preventDefault();

    // If not running -> start (initial start OR restart after death)
    if (!gameRunning) {
      startGame();
      return;
    }

    // else perform jump
    jump();
  });

  // ensure canvas is focusable and focused so keydown reliably received
  canvas.setAttribute("tabindex", "0");
  canvas.style.outline = "none";
  canvas.addEventListener("click", () => canvas.focus());

  // initial draw
  (function initialDraw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#444";
    ctx.fillRect(0, GROUND_Y + dino.h, canvas.width, 2);
    ctx.fillStyle = "#2c7";
    ctx.fillRect(dino.x, dino.y, dino.w, dino.h);
  })();
})();
</script>
{% endblock %}
